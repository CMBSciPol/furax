from functools import partial

import jax
import jax.numpy as jnp
import lineax as lx
from jaxtyping import Array, ArrayLike, Float, PRNGKeyArray

from furax import FourierOperator, IndexOperator, SymmetricBandToeplitzOperator
from furax._config import verbose_solver_callback
from furax.obs._detectors import DetectorArray

__all__ = [
    'GapFillingOperator',
    'generate_noise_realization',
]


class GapFillingOperator:
    """Class for filling masked time samples with a constrained noise realization.

    We follow the gap-filling algorithm described in https://doi.org/10.1103/PhysRevD.65.022003,
    section II.C, page 6. It assumes that the noise is piece wise stationary and has Gaussian
    statistics, described by the covariance matrix ``cov``.

    Example:
    Gap-filling a single-detector timestream

        >>> detectors = DetectorArray(jnp.array(0), jnp.array(0), jnp.array(1))
        >>> key = jax.random.key(0)
        >>> key, subkey = jax.random.split(key)
        >>> nsamples = 10
        >>> x = jax.random.normal(subkey, detectors.shape + (nsamples,))
        >>> in_structure = jax.ShapeDtypeStruct(x.shape, x.dtype)
        >>> mask = jnp.array([1, 1, 1, 0, 0, 1, 1, 1, 1, 1], dtype=bool)
        >>> mask_op = IndexOperator(jnp.where(mask), in_structure=in_structure)
        >>> cov = SymmetricBandToeplitzOperator(jnp.array([1.0]), in_structure)
        >>> gf = GapFillingOperator(cov, mask_op, detectors)
        >>> gap_filled_x = gf(key, x)
        >>> assert gap_filled_x.shape == x.shape
        >>> assert jnp.all(gap_filled_x[mask] == x[mask])
    """

    def __init__(
        self,
        cov: SymmetricBandToeplitzOperator | FourierOperator,
        mask_op: IndexOperator,
        detectors: DetectorArray | None = None,
        icov: SymmetricBandToeplitzOperator | FourierOperator | None = None,
        *,
        rate: float = 1.0,
        max_cg_steps: int = 300,
        verbose: bool = False,
    ):
        """Initializes the gap-filling operator.

        Args:
            cov: Operator representing the noise covariance.
            mask_op: Operator for masking the gaps.
            detectors: The detector array (optional, useful for reproducibility).
            icov: The inverse covariance operator, to serve as a preconditioner (optional).
            rate: The sampling rate of the data.
            max_cg_steps: Maximum number of Conjugate Gradient steps to use.
            verbose: Whether to print verbose output during CG solves.
        """
        if not isinstance(cov, SymmetricBandToeplitzOperator | FourierOperator):
            raise ValueError('Unsupported covariance operator.')
        self.cov = cov
        self.icov = icov
        self.mask_op = mask_op
        self.detectors = detectors
        self.rate = rate
        self._cg_config = {'solver': lx.CG(rtol=1e-6, atol=0, max_steps=max_cg_steps)}
        if verbose:
            self._cg_config['callback'] = verbose_solver_callback

    def __call__(self, key: PRNGKeyArray, x: Float[Array, ' *shape']) -> Float[Array, ' *shape']:
        """Performs the gap-filling operation.

        Args:
            key: A PRNG key generated by the user.
            x: The vector to be filled.
        """
        # generate a noise realization following the noise covariance
        xi = generate_noise_realization(key, self.cov, self.detectors, fsamp=self.rate)
        p, u = self.mask_op, self.mask_op.T  # pack, unpack operators
        incomplete_cov = p @ self.cov @ u
        cg_config = self._cg_config.copy()
        if self.icov is not None:
            # Use this approximation as a preconditioner
            cg_config['preconditioner'] = p @ self.icov @ u
        op = self.cov @ u @ incomplete_cov.I(**cg_config) @ p
        y = xi + op(x - xi)
        # copy valid samples from original vector
        return y.at[p.indices].set(p(x))  # type: ignore[no-any-return]


def _get_kernel(n_tt: Float[Array, ' _'], size: int) -> Float[Array, ' {size}']:
    lagmax = n_tt.size - 1
    padding_size = size - (2 * lagmax + 1)
    if padding_size < 0:
        msg = f'The maximum lag ({lagmax}) is too large for the required kernel size ({size}).'
        raise ValueError(msg)
    kernel = jnp.concatenate((n_tt, jnp.zeros(padding_size), n_tt[-1:0:-1]))
    return kernel


@partial(jnp.vectorize, signature='(b)->(k)', excluded={1})
def _folded_psd(
    n_tt: Float[ArrayLike, ' _'], fft_size: int
) -> Float[Array, ' {fft_size // 2 + 1}']:
    """Returns the folded Power Spectral Density of a one-dimensional vector.

    Args:
        n_tt: The autocorrelation function of the vector.
        fft_size: The size of the FFT to use (at least twice the size of ``n_tt``).
    """
    n_tt = jnp.asarray(n_tt)
    kernel = _get_kernel(n_tt, fft_size)
    psd = jnp.abs(jnp.fft.rfft(kernel, n=fft_size))
    # zero out DC value
    psd = psd.at[0].set(0)
    return psd


@partial(jax.jit, static_argnames=('detectors'))
def generate_noise_realization(
    key: PRNGKeyArray,
    cov: FourierOperator | SymmetricBandToeplitzOperator,
    detectors: DetectorArray | None = None,
    fsamp: float = 1.0,
) -> Float[Array, ' *shape']:
    """Generates a Gaussian noise realization with the given covariance.

    Args:
        key: A PRNG key generated by the user.
        cov: The noise covariance matrix/operator.
            The operator's structure is the output structure of this function.
        detectors: The detector array (optional, useful for reproducibility).
        fsamp: The sampling frequency of the data (recommended for correct normalization).
    """
    # Structure of the vector that will be generated
    structure = cov.in_structure()

    # Get the PSD values from the covariance matrix
    n = structure.shape[-1]
    if isinstance(cov, FourierOperator):
        fft_size = cov.fft_size
        psd = cov.get_kernel()
    elif isinstance(cov, SymmetricBandToeplitzOperator):
        fft_size = SymmetricBandToeplitzOperator._get_default_fft_size(n)
        psd = _folded_psd(cov.band_values, fft_size)
    else:
        raise NotImplementedError

    npsd = fft_size // 2 + 1
    if npsd != psd.shape[-1]:
        msg = f'PSD size {psd.shape[-1]} does not match expected size {npsd} for {fft_size=}.'
        raise ValueError(msg)

    @partial(jnp.vectorize, signature='(),(k)->(n)')
    def func(subkey, psd):  # type: ignore[no-untyped-def]
        # Gaussian Re/Im random numbers
        rngdata = jax.random.normal(subkey, shape=(fft_size,))

        # Set DC and Nyquist frequency imaginary parts to zero
        fdata = jnp.empty(npsd, dtype=complex)
        fdata = fdata.at[0].set(rngdata[0] + 0.0j)
        fdata = fdata.at[-1].set(rngdata[npsd - 1] + 0.0j)

        # Repack the other values
        fdata = fdata.at[1:-1].set(rngdata[1 : npsd - 1] + 1j * rngdata[-1 : npsd - 1 : -1])

        # Normalization factor
        norm = fsamp * float(npsd - 1) / 2

        # Scale by PSD and inverse FFT
        scale = jnp.sqrt(norm * psd)
        tdata = jnp.fft.irfft(fdata * scale)

        # Extract the samples we want and remove DC level
        offset = (fft_size - n) // 2
        xi = tdata[offset : offset + n]
        return xi - jnp.mean(xi)

    if detectors is None:
        subkeys = jax.random.split(key, structure.shape[:-1])
    else:
        # this folds in the detector names for reproducibility
        assert detectors.shape == structure.shape[:-1]
        subkeys = detectors.split_key(key)

    return func(subkeys, psd)  # type: ignore[no-any-return]
